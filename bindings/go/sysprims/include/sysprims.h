/* sysprims C-ABI - Generated by cbindgen - DO NOT EDIT */

#ifndef SYSPRIMS_H
#define SYSPRIMS_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * FFI error codes.
 *
 * These map directly to `SysprimsError` variants. See `sysprims_core::error`
 * for the authoritative error taxonomy.
 */
enum SysprimsErrorCode {
    /**
     * No error - operation succeeded.
     */
    SYSPRIMS_ERROR_CODE_OK = 0,
    /**
     * Invalid argument provided.
     */
    SYSPRIMS_ERROR_CODE_INVALID_ARGUMENT = 1,
    /**
     * Failed to spawn child process.
     */
    SYSPRIMS_ERROR_CODE_SPAWN_FAILED = 2,
    /**
     * Operation timed out.
     */
    SYSPRIMS_ERROR_CODE_TIMEOUT = 3,
    /**
     * Permission denied for operation.
     */
    SYSPRIMS_ERROR_CODE_PERMISSION_DENIED = 4,
    /**
     * Process or command not found.
     */
    SYSPRIMS_ERROR_CODE_NOT_FOUND = 5,
    /**
     * Operation not supported on this platform.
     */
    SYSPRIMS_ERROR_CODE_NOT_SUPPORTED = 6,
    /**
     * Failed to create process group or job object.
     */
    SYSPRIMS_ERROR_CODE_GROUP_CREATION_FAILED = 7,
    /**
     * System-level error (errno/GetLastError).
     */
    SYSPRIMS_ERROR_CODE_SYSTEM = 8,
    /**
     * Internal error (bug in sysprims).
     */
    SYSPRIMS_ERROR_CODE_INTERNAL = 99,
};
typedef int32_t SysprimsErrorCode;

/**
 * Process grouping mode for timeout execution.
 *
 * Controls whether timeout creates a process group (Unix) or Job Object
 * (Windows) to enable tree-kill on timeout.
 */
enum SysprimsGroupingMode {
    /**
     * Create new process group (Unix) or Job Object (Windows).
     * Kill entire tree on timeout. This is the recommended default.
     */
    SYSPRIMS_GROUPING_MODE_GROUP_BY_DEFAULT = 0,
    /**
     * Run in foreground. Only kills direct child on timeout.
     */
    SYSPRIMS_GROUPING_MODE_FOREGROUND = 1,
};
typedef int32_t SysprimsGroupingMode;

/**
 * Configuration for timeout execution.
 *
 * All string pointers must be valid UTF-8 C strings.
 */
typedef struct SysprimsTimeoutConfig {
    /**
     * Command to execute (must not be NULL).
     */
    const char *command;
    /**
     * Argument array (may be NULL for no arguments).
     */
    const char *const *args;
    /**
     * Number of arguments in `args` array.
     */
    uintptr_t args_len;
    /**
     * Timeout duration in milliseconds.
     */
    uint64_t timeout_ms;
    /**
     * Delay before escalating to SIGKILL, in milliseconds.
     * Set to 0 for immediate escalation (no grace period).
     */
    uint64_t kill_after_ms;
    /**
     * Signal to send on timeout (e.g., 15 for SIGTERM).
     */
    int32_t signal;
    /**
     * Process grouping mode.
     */
    SysprimsGroupingMode grouping;
    /**
     * Whether to preserve the child's exit code.
     */
    bool preserve_status;
} SysprimsTimeoutConfig;

























/**
 * Get the library version string.
 *
 * Returns a static string like "0.1.0". The pointer is valid for the
 * lifetime of the library and should NOT be freed.
 *
 * # Example (C)
 *
 * ```c
 * const char* ver = sysprims_version();
 * printf("sysprims version: %s\n", ver);
 * // Do NOT call sysprims_free_string(ver)
 * ```
 */
const char *sysprims_version(void);

/**
 * Get the ABI version number.
 *
 * Use this to check compatibility between the library and bindings.
 * If the ABI version differs from what your bindings expect, the
 * bindings may not work correctly.
 *
 * # Example (C)
 *
 * ```c
 * uint32_t abi = sysprims_abi_version();
 * if (abi != EXPECTED_ABI_VERSION) {
 *     fprintf(stderr, "ABI mismatch: expected %u, got %u\n",
 *             EXPECTED_ABI_VERSION, abi);
 * }
 * ```
 */
uint32_t sysprims_abi_version(void);

/**
 * Returns the current platform name as a C string.
 *
 * Returns one of: "linux", "macos", "windows", "freebsd", etc.
 *
 * # Safety
 *
 * The returned pointer must be freed with `sysprims_free_string()`.
 * Do not use `free()` or any other deallocator.
 */
char *sysprims_get_platform(void);

/**
 * Frees a string allocated by sysprims functions.
 *
 * # Safety
 *
 * The pointer must have been returned by a sysprims function that
 * allocates strings (e.g., `sysprims_get_platform()`, `sysprims_last_error()`).
 * Passing null is safe and will be a no-op.
 *
 * Do NOT pass pointers returned by `sysprims_version()` - those are
 * static strings that should not be freed.
 *
 * # C Usage
 *
 * ```c
 * char* platform = sysprims_get_platform();
 * // use platform...
 * sysprims_free_string(platform);  // Must free with this function
 * ```
 */
void sysprims_free_string(char *s);

/**
 * Get the error code from the last failed operation.
 *
 * Returns `SYSPRIMS_OK` (0) if the last operation succeeded.
 *
 * # Thread Safety
 *
 * Error state is thread-local. Each thread has its own error state.
 */
SysprimsErrorCode sysprims_last_error_code(void);

/**
 * Get the error message from the last failed operation.
 *
 * Returns an owned string (must be freed with `sysprims_free_string()`).
 *
 * After a successful operation (or after calling `sysprims_clear_error()`),
 * this returns an empty string (`""`).
 *
 * # Safety
 *
 * The returned pointer must be freed with `sysprims_free_string()`.
 * The caller owns the returned string.
 *
 * # Thread Safety
 *
 * Error state is thread-local. Each thread has its own error state.
 */
char *sysprims_last_error(void);

/**
 * Clear the error state for the current thread.
 *
 * After calling this function, `sysprims_last_error_code()` will return
 * `SYSPRIMS_OK` and `sysprims_last_error()` will return an empty string.
 */
void sysprims_clear_error(void);

/**
 * List listening ports, optionally filtered.
 *
 * Returns a JSON object containing a port bindings snapshot.
 *
 * # Arguments
 *
 * * `filter_json` - JSON filter object (may be NULL for no filtering)
 * * `result_json_out` - Output pointer for result JSON string
 *
 * # Filter JSON Format
 *
 * ```json
 * {
 *   "protocol": "tcp",    // Optional: "tcp" or "udp"
 *   "local_port": 8080    // Optional: local port to filter
 * }
 * ```
 *
 * # Safety
 *
 * * `result_json_out` must be a valid pointer to a `char*`
 * * The result string must be freed with `sysprims_free_string()`
 */
SysprimsErrorCode sysprims_proc_listening_ports(const char *filter_json, char **result_json_out);

/**
 * List processes, optionally filtered.
 *
 * Returns a JSON object containing a process snapshot. The JSON format matches
 * the `ProcessSnapshot` schema with `schema_id`, `timestamp`, and `processes`.
 *
 * # Arguments
 *
 * * `filter_json` - JSON filter object (may be NULL for no filtering)
 * * `result_json_out` - Output pointer for result JSON string
 *
 * # Filter JSON Format
 *
 * ```json
 * {
 *   "name_contains": "nginx",     // Optional: filter by name substring
 *   "name_equals": "nginx",       // Optional: filter by exact name
 *   "user_equals": "www-data",    // Optional: filter by username
 *   "pid_in": [1234, 5678],       // Optional: filter to specific PIDs
 *   "cpu_above": 10.0,            // Optional: minimum CPU percent (0-100)
 *   "memory_above_kb": 1024       // Optional: minimum memory in KB
 * }
 * ```
 *
 * # Returns
 *
 * * `SYSPRIMS_OK` on success (result written to `result_json_out`)
 * * `SYSPRIMS_ERR_INVALID_ARGUMENT` if filter JSON is invalid
 * * `SYSPRIMS_ERR_SYSTEM` on system error
 *
 * # Safety
 *
 * * `result_json_out` must be a valid pointer to a `char*`
 * * The result string must be freed with `sysprims_free_string()`
 *
 * # Example (C)
 *
 * ```c
 * char* result = NULL;
 * SysprimsErrorCode err = sysprims_proc_list(NULL, &result);
 * if (err == SYSPRIMS_OK) {
 *     printf("%s\n", result);
 *     sysprims_free_string(result);
 * }
 * ```
 */
SysprimsErrorCode sysprims_proc_list(const char *filter_json, char **result_json_out);

/**
 * Get information for a single process by PID.
 *
 * Returns JSON for a single process. If the process doesn't exist,
 * returns `SYSPRIMS_ERR_NOT_FOUND`.
 *
 * # Arguments
 *
 * * `pid` - Process ID to query
 * * `result_json_out` - Output pointer for result JSON string
 *
 * # Result JSON Format
 *
 * ```json
 * {
 *   "pid": 1234,
 *   "ppid": 1,
 *   "name": "nginx",
 *   "user": "www-data",
 *   "cpu_percent": 5.2,
 *   "memory_kb": 102400,
 *   "elapsed_seconds": 3600,
 *   "state": "running",
 *   "cmdline": ["nginx", "-g", "daemon off;"]
 * }
 * ```
 *
 * # Returns
 *
 * * `SYSPRIMS_OK` on success
 * * `SYSPRIMS_ERR_INVALID_ARGUMENT` if pid is 0
 * * `SYSPRIMS_ERR_NOT_FOUND` if process doesn't exist
 * * `SYSPRIMS_ERR_PERMISSION_DENIED` if not permitted to read process
 *
 * # Safety
 *
 * * `result_json_out` must be a valid pointer to a `char*`
 * * The result string must be freed with `sysprims_free_string()`
 *
 * # Example (C)
 *
 * ```c
 * char* result = NULL;
 * SysprimsErrorCode err = sysprims_proc_get(getpid(), &result);
 * if (err == SYSPRIMS_OK) {
 *     printf("%s\n", result);
 *     sysprims_free_string(result);
 * }
 * ```
 */
SysprimsErrorCode sysprims_proc_get(uint32_t pid, char **result_json_out);

/**
 * Wait for a PID to exit, up to a timeout.
 *
 * Returns a JSON object matching `wait-pid-result.schema.json`.
 *
 * # Arguments
 *
 * * `pid` - PID to wait on (must be > 0)
 * * `timeout_ms` - Timeout in milliseconds
 * * `result_json_out` - Output pointer for result JSON string
 *
 * # Safety
 *
 * * `result_json_out` must be a valid pointer to a `char*`
 * * The result string must be freed with `sysprims_free_string()`
 */
SysprimsErrorCode sysprims_proc_wait_pid(uint32_t pid, uint64_t timeout_ms, char **result_json_out);

/**
 * Get the current process group ID (PGID).
 *
 * On Unix, this calls `getpgid(0)`.
 * On Windows, this returns `SYSPRIMS_ERR_NOT_SUPPORTED`.
 *
 * # Safety
 *
 * - `pgid_out` must be a valid pointer to a `u32`.
 */
SysprimsErrorCode sysprims_self_getpgid(unsigned int *pgid_out);

/**
 * Get the current session ID (SID).
 *
 * On Unix, this calls `getsid(0)`.
 * On Windows, this returns `SYSPRIMS_ERR_NOT_SUPPORTED`.
 *
 * # Safety
 *
 * - `sid_out` must be a valid pointer to a `u32`.
 */
SysprimsErrorCode sysprims_self_getsid(unsigned int *sid_out);

/**
 * Send a signal to a process.
 *
 * On Unix, this calls `kill(pid, signal)`.
 * On Windows, SIGTERM and SIGKILL are mapped to `TerminateProcess`.
 * Other signals return `SYSPRIMS_ERR_NOT_SUPPORTED`.
 *
 * # Arguments
 *
 * * `pid` - Process ID (must be > 0 and <= i32::MAX)
 * * `signal` - Signal number (e.g., 15 for SIGTERM, 9 for SIGKILL)
 *
 * # Returns
 *
 * * `SYSPRIMS_OK` on success
 * * `SYSPRIMS_ERR_INVALID_ARGUMENT` if pid is 0 or > i32::MAX
 * * `SYSPRIMS_ERR_NOT_FOUND` if process doesn't exist
 * * `SYSPRIMS_ERR_PERMISSION_DENIED` if not permitted
 * * `SYSPRIMS_ERR_NOT_SUPPORTED` for unsupported signals on Windows
 *
 * # Example (C)
 *
 * ```c
 * SysprimsErrorCode err = sysprims_signal_send(pid, 15); // SIGTERM
 * if (err != SYSPRIMS_OK) {
 *     char* msg = sysprims_last_error();
 *     fprintf(stderr, "Error: %s\n", msg);
 *     sysprims_free_string(msg);
 * }
 * ```
 */
SysprimsErrorCode sysprims_signal_send(uint32_t pid, int32_t signal);

/**
 * Send a signal to a process group.
 *
 * On Unix, this calls `killpg(pgid, signal)`.
 * On Windows, this always returns `SYSPRIMS_ERR_NOT_SUPPORTED`.
 *
 * # Arguments
 *
 * * `pgid` - Process group ID (must be > 0 and <= i32::MAX)
 * * `signal` - Signal number
 *
 * # Returns
 *
 * * `SYSPRIMS_OK` on success
 * * `SYSPRIMS_ERR_INVALID_ARGUMENT` if pgid is invalid
 * * `SYSPRIMS_ERR_NOT_SUPPORTED` on Windows
 *
 * # Example (C)
 *
 * ```c
 * #ifdef _WIN32
 * // Not supported on Windows
 * #else
 * SysprimsErrorCode err = sysprims_signal_send_group(pgid, 15);
 * #endif
 * ```
 */
SysprimsErrorCode sysprims_signal_send_group(uint32_t pgid, int32_t signal);

/**
 * Send SIGTERM to a process.
 *
 * Convenience wrapper for `sysprims_signal_send(pid, SIGTERM)`.
 *
 * On Windows, this calls `TerminateProcess`.
 *
 * # Arguments
 *
 * * `pid` - Process ID
 *
 * # Returns
 *
 * * `SYSPRIMS_OK` on success
 * * Error code on failure (see `sysprims_signal_send`)
 */
SysprimsErrorCode sysprims_terminate(uint32_t pid);

/**
 * Send SIGKILL to a process (force kill).
 *
 * Convenience wrapper for `sysprims_signal_send(pid, SIGKILL)`.
 *
 * On Unix, this sends SIGKILL which cannot be caught or ignored.
 * On Windows, this calls `TerminateProcess`.
 *
 * # Arguments
 *
 * * `pid` - Process ID
 *
 * # Returns
 *
 * * `SYSPRIMS_OK` on success
 * * Error code on failure (see `sysprims_signal_send`)
 */
SysprimsErrorCode sysprims_force_kill(uint32_t pid);

/**
 * Run a command with timeout.
 *
 * Spawns the command and waits for it to complete or timeout. If the command
 * times out, the entire process tree is killed (when using GroupByDefault).
 *
 * # Arguments
 *
 * * `config` - Timeout configuration (must not be NULL)
 * * `result_json_out` - Output pointer for result JSON string
 *
 * # Result JSON Format
 *
 * ```json
 * // Completed:
 * {
 *   "status": "completed",
 *   "exit_code": 0
 * }
 *
 * // Timed out:
 * {
 *   "status": "timed_out",
 *   "signal_sent": 15,
 *   "escalated": false,
 *   "tree_kill_reliability": "guaranteed"
 * }
 * ```
 *
 * # Returns
 *
 * * `SYSPRIMS_OK` on success (result written to `result_json_out`)
 * * `SYSPRIMS_ERR_INVALID_ARGUMENT` if config is invalid
 * * `SYSPRIMS_ERR_SPAWN_FAILED` if command couldn't be spawned
 * * `SYSPRIMS_ERR_NOT_FOUND` if command doesn't exist
 * * `SYSPRIMS_ERR_PERMISSION_DENIED` if command isn't executable
 *
 * # Safety
 *
 * * `config` must be a valid pointer to `SysprimsTimeoutConfig`
 * * `config.command` must be a valid, non-null C string
 * * `config.args` may be null (no arguments) or a valid array
 * * `result_json_out` must be a valid pointer to a `char*`
 * * The result string must be freed with `sysprims_free_string()`
 *
 * # Example (C)
 *
 * ```c
 * SysprimsTimeoutConfig config = {
 *     .command = "/bin/sleep",
 *     .args = (const char*[]){ "10", NULL },
 *     .args_len = 1,
 *     .timeout_ms = 5000,
 *     .kill_after_ms = 2000,
 *     .signal = 15,  // SIGTERM
 *     .grouping = SYSPRIMS_GROUP_BY_DEFAULT,
 *     .preserve_status = false,
 * };
 *
 * char* result = NULL;
 * SysprimsErrorCode err = sysprims_timeout_run(&config, &result);
 * if (err == SYSPRIMS_OK) {
 *     printf("%s\n", result);
 *     sysprims_free_string(result);
 * }
 * ```
 */
SysprimsErrorCode sysprims_timeout_run(const struct SysprimsTimeoutConfig *config,
                                       char **result_json_out);

/**
 * Terminate a process (best-effort tree) with escalation.
 *
 * Returns a JSON object matching `terminate-tree-result.schema.json`.
 *
 * # Arguments
 *
 * * `pid` - Process ID to terminate (must be > 0)
 * * `config_json` - Optional JSON config (NULL/empty/"{}" for defaults)
 * * `result_json_out` - Output pointer for result JSON string
 *
 * # Safety
 *
 * * `result_json_out` must be a valid pointer to a `char*`
 * * The result string must be freed with `sysprims_free_string()`
 */
SysprimsErrorCode sysprims_terminate_tree(uint32_t pid,
                                          const char *config_json,
                                          char **result_json_out);

#endif  /* SYSPRIMS_H */
