name: TypeScript npm Publish

# Publishes TypeScript bindings to npm using OIDC trusted publishing.
# See docs/ops/npm-publishing.md for setup instructions.
#
# Prerequisites:
# - Package must already exist on npm (first publish is manual)
# - Trusted publisher configured on npmjs.com for this workflow
# - Prebuilds workflow must have completed successfully

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to publish (must match the workflow ref, e.g. v0.1.8)"
        required: false
        type: string
      prebuilds_run_id:
        description: "Prebuilds workflow run ID (leave empty for latest successful)"
        required: false
        type: string
      dry_run:
        description: "Dry run (validate but don't publish)"
        required: false
        type: boolean
        default: false

permissions:
  id-token: write   # Required for OIDC trusted publishing
  contents: read
  actions: read     # Required to download artifacts from other runs

jobs:
  publish:
    name: Publish to npm
    runs-on: ubuntu-latest
    environment: publish-npm  # Required for npm OIDC trusted publishing
    steps:
      # Note: Do NOT use fetch-tags here. When running from a tag ref,
      # it causes a git fetch conflict. The tag is already checked out.
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org'

      - name: Validate running from a tag ref
        run: |
          set -euo pipefail
          if [ "${GITHUB_REF_TYPE:-}" != "tag" ]; then
            echo "::error::This workflow must run from a tag ref (refs/tags/vX.Y.Z)."
            echo "Re-run it selecting the release tag in the GitHub UI, or trigger it by pushing a v* tag."
            exit 1
          fi

      - name: Validate release tag and versions
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          if [ -n "${{ inputs.tag }}" ] && [ "${{ inputs.tag }}" != "$TAG" ]; then
            echo "::error::Input tag does not match workflow ref"
            echo "input.tag=${{ inputs.tag }}"
            echo "ref.tag=${TAG}"
            exit 1
          fi

          VERSION_FROM_TAG="${TAG#v}"
          VERSION_FILE=$(cat VERSION)
          if [ "$VERSION_FILE" != "$VERSION_FROM_TAG" ]; then
            echo "::error::VERSION file does not match tag"
            echo "VERSION=$VERSION_FILE"
            echo "tag=$TAG"
            exit 1
          fi

          PKG_VERSION=$(node -p "require('./bindings/typescript/sysprims/package.json').version")
          if [ "$PKG_VERSION" != "$VERSION_FROM_TAG" ]; then
            echo "::error::bindings/typescript/sysprims/package.json version does not match tag"
            echo "package.json=$PKG_VERSION"
            echo "tag=$TAG"
            exit 1
          fi

          {
            echo "version=${VERSION_FROM_TAG}"
            echo "tag=${TAG}"
            echo "head_sha=$(git rev-parse HEAD)"
          } >> "$GITHUB_ENV"
          echo "Validated tag/version: ${TAG}"

      - name: Find prebuilds run
        id: find-run
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          if [ -n "${{ inputs.prebuilds_run_id }}" ]; then
            RUN_ID="${{ inputs.prebuilds_run_id }}"
            echo "Using specified run ID: ${RUN_ID}"

            RUN_SHA=$(gh run view "${RUN_ID}" --json headSha --jq '.headSha')
            if [ -z "$RUN_SHA" ] || [ "$RUN_SHA" = "null" ]; then
              echo "::error::Could not determine headSha for run ${RUN_ID}"
              exit 1
            fi
            if [ "$RUN_SHA" != "${{ env.head_sha }}" ]; then
              echo "::error::Prebuild run ${RUN_ID} was built from ${RUN_SHA}, expected ${{ env.head_sha }}"
              echo "Use a prebuilds run from the tagged commit, or omit prebuilds_run_id to auto-select."
              exit 1
            fi
          else
            echo "Finding latest successful prebuilds run..."
            RUN_ID=$(gh run list \
              --workflow=typescript-napi-prebuilds.yml \
              --status=success \
              --limit=50 \
              --json databaseId,headSha \
              --jq '.[] | select(.headSha == "${{ env.head_sha }}") | .databaseId' \
              | head -n 1)

            if [ -z "$RUN_ID" ] || [ "$RUN_ID" = "null" ]; then
              echo "::error::No successful prebuilds run found for commit ${{ env.head_sha }}"
              echo "Run the TypeScript N-API Prebuilds workflow on the tagged commit, or pass prebuilds_run_id."
              exit 1
            fi
            echo "Found run ID: ${RUN_ID}"
          fi

          echo "run_id=${RUN_ID}" >> "$GITHUB_OUTPUT"

      - name: Download npm directory artifact
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          RUN_ID="${{ steps.find-run.outputs.run_id }}"

          echo "Downloading ts-npm-dir artifact from run ${RUN_ID}..."
          # GitHub-hosted runners occasionally hit transient network errors to api.github.com.
          # Retry here to avoid burning a full workflow rerun on a short blip.
          for attempt in 1 2 3 4 5; do
            if gh run download "${RUN_ID}" --name ts-npm-dir --dir npm-packages; then
              break
            fi
            rc=$?
            echo "::warning::Artifact download failed (attempt ${attempt}/5, rc=${rc}). Retrying..."
            sleep $((attempt * attempt))
          done

          if [ ! -d "npm-packages" ] || [ -z "$(ls -A npm-packages 2>/dev/null)" ]; then
            echo "::error::Failed to download ts-npm-dir artifact from run ${RUN_ID} after retries"
            exit 1
          fi

          echo "Downloaded packages:"
          ls -la npm-packages/

      - name: Verify packages
        run: |
          set -euo pipefail

          VERSION="${{ env.version }}"

          # Expected platform packages
          PLATFORMS=(
            "linux-x64-gnu"
            "linux-x64-musl"
            "linux-arm64-gnu"
            "linux-arm64-musl"
            "darwin-arm64"
            "win32-x64-msvc"
            "win32-arm64-msvc"
          )

          echo "Verifying platform packages..."
          for plat in "${PLATFORMS[@]}"; do
            if [ ! -d "npm-packages/${plat}" ]; then
              echo "::error::Missing platform package: ${plat}"
              exit 1
            fi
            if [ ! -f "npm-packages/${plat}/sysprims.${plat}.node" ]; then
              echo "::error::Missing .node file in ${plat}"
              exit 1
            fi

            PKG_JSON="npm-packages/${plat}/package.json"
            if [ ! -f "$PKG_JSON" ]; then
              echo "::error::Missing package.json in ${plat}"
              exit 1
            fi
            PKG_VERSION=$(node -p "require('./' + process.argv[1]).version" "$PKG_JSON")
            if [ "$PKG_VERSION" != "$VERSION" ]; then
              echo "::error::Version mismatch in ${plat} package.json (${PKG_VERSION} != ${VERSION})"
              exit 1
            fi
            echo "  ${plat}: OK"
          done

          echo "All platform packages verified"

      - name: Build root package
        working-directory: bindings/typescript/sysprims
        run: |
          set -euo pipefail
          # Use npm install instead of npm ci because:
          # 1. Optional dependencies (platform packages) are being published in this workflow
          # 2. They don't exist yet when we build the root package
          # 3. We only need devDependencies for TypeScript compilation
          npm install --omit=optional
          npm run build

      - name: Publish (dry run)
        if: ${{ inputs.dry_run }}
        working-directory: bindings/typescript/sysprims
        run: |
          set -euo pipefail
          echo "=== DRY RUN - No packages will be published ==="

          echo "Platform packages:"
          for dir in ../../../npm-packages/*/; do
            (cd "$dir" && npm publish --access public --dry-run)
          done

          echo "Root package:"
          npm publish --access public --dry-run

      - name: Publish platform packages
        if: ${{ !inputs.dry_run }}
        run: |
          set -euo pipefail

          echo "Publishing platform packages..."
          for dir in npm-packages/*/; do
            pkg=$(basename "$dir")
            echo "Publishing @3leaps/sysprims-${pkg}..."
            (cd "$dir" && npm publish --access public)
          done

      - name: Publish root package
        if: ${{ !inputs.dry_run }}
        working-directory: bindings/typescript/sysprims
        run: |
          set -euo pipefail
          echo "Publishing @3leaps/sysprims..."
          npm publish --access public

      - name: Verify publication
        if: ${{ !inputs.dry_run }}
        run: |
          set -euo pipefail
          VERSION="${{ env.version }}"

          echo "Waiting for npm to index packages..."
          sleep 10

          echo "Verifying @3leaps/sysprims@${VERSION}..."
          npm view "@3leaps/sysprims@${VERSION}" version || {
            echo "::warning::Package not yet visible on npm (may take a few minutes)"
          }
