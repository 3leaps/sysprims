# v0.1.14 - Process Intelligence & Go Team Depth

**Release Date:** 2026-02-24
**Status:** Released

## Summary

v0.1.14 closes the gap between what sysprims knows about a process and what it exposes to callers.
The headline capability is `proc_ext` — environment variables and thread count surfaced through the
Rust library, FFI, and Go/TypeScript bindings — enabling Go teams to replace `ps`, `lsof`, and
`kill` shell-outs with a single typed, license-clean library call.

Secondary themes: CPU measurement parity across all process-tree commands (fixing a real-world
gap found during dogfooding where lifetime CPU missed 2 of 4 spinning zombie processes), and
schema contract compliance hardening.

This release is designed to be the one where Go platform teams look at the API and say
"this replaces something I was shelling out to."

## Highlights

- **`proc_ext`**: `env` and `thread_count` fields on `ProcessInfo` — opt-in, zero cost when not
  requested. Available in Rust, Go, TypeScript, and FFI.
- **CPU mode on `descendants`/`kill-descendants`**: `--cpu-mode monitor --sample 3s` now works on
  tree commands, not just `pstat`. Finds bursty/spinning processes that lifetime averaging misses.
- **Schema compliance fix**: `pstat --pid --json` now emits the `schema_id` envelope required by
  ADR-0005. Was returning a flat object — a contract violation, not just a style issue.
- **Contextual hints**: `--cpu-above` without `--cpu-mode monitor` now prints a stderr hint
  suggesting the more accurate measurement mode.
- **Library and CLI documentation sprint**: rustdoc examples on every public function; Go pkg docs
  updated; CLI `after_help` examples added to high-complexity subcommands.

## Changes

### Wave 1: Foundation

#### `proc_ext` — Environment Variables and Thread Count

Activates the `proc_ext` feature flag defined in ADR-0002 (`# Extended info (env, threads, IO)`).
This was designed into the architecture from the start; this release implements it.

**New fields on `ProcessInfo`** (optional, default `null`/`None`):

```rust
pub struct ProcessInfo {
    // ... existing fields ...
    pub env: Option<BTreeMap<String, String>>, // proc_ext
    pub thread_count: Option<u32>,             // proc_ext
}
```

**Opt-in at call site** — no performance impact when not requested:

```rust
use sysprims_proc::{get_process_with_options, snapshot_with_options, ProcessOptions};

// Get a single process with env and thread count
let proc = get_process_with_options(
    pid,
    ProcessOptions::default().with_env().with_threads(),
)?;
println!("Threads: {:?}", proc.thread_count);
println!("NODE_ENV: {:?}", proc.env.as_ref().and_then(|e| e.get("NODE_ENV")));

// Snapshot with thread counts (no env — selective opt-in)
let snap = snapshot_with_options(ProcessOptions::default().with_threads())?;
```

**Go binding** — the primary audience for this release:

```go
import "github.com/3leaps/sysprims/bindings/go/sysprims"

// Replace: ps eww -p <pid> + text parsing
proc, err := sysprims.ProcessGetWithOptions(pid, &sysprims.ProcessOptions{
    IncludeEnv:     true,
    IncludeThreads: true,
})
if err != nil {
    return err
}
fmt.Println("NODE_ENV:", proc.Env["NODE_ENV"])
fmt.Println("threads:", proc.ThreadCount)

// Replace: pgrep + ps + grep pattern
name := "worker"
procs, err := sysprims.ProcessListWithOptions(
    &sysprims.ProcessFilter{NameContains: &name},
    &sysprims.ProcessOptions{IncludeThreads: true},
)
_ = procs
```

**TypeScript binding**:

```typescript
import { procGet, processList } from "@3leaps/sysprims";

const proc = procGet(pid, { includeEnv: true, includeThreads: true });
console.log(proc.env?.NODE_ENV);
console.log(proc.threadCount);
```

**FFI** (`options_json` gains two optional boolean fields):

```c
const char *options_json = "{\"include_env\":true,\"include_threads\":true}";
sysprims_proc_get_ex(1234, options_json, &result_json_out);
```

**Platform coverage**:

| Platform |                       `env`                       |         `thread_count`         |
| -------- | :-----------------------------------------------: | :----------------------------: |
| Linux    |               `/proc/[pid]/environ`               | `/proc/[pid]/status` (Threads) |
| macOS    | `sysctl(KERN_PROCARGS2)` (env block follows argv) |        `proc_taskinfo`         |
| Windows  |          Not supported v0.1.14 (`null`)           |           Toolhelp32           |

macOS env: the `KERN_PROCARGS2` buffer layout is `[argc][exec_path\0][argv...][env...]`.
The v0.1.13 cmdline implementation already reads this buffer — env is the next block.
Same syscall, second pass over the same data.

**Schema**: `ProcessInfo` schema bumps to v1.1.0 (two new optional fields — minor per ADR-0005).

---

#### Schema Compliance: `pstat --pid --json` (ADR-0005 fix)

`pstat --pid X --json` was returning a flat `ProcessInfo` object with no `schema_id` envelope.
ADR-0005 requires `schema_id` on every JSON output without exception. This is a contract bug.

**Before (v0.1.13):**

```json
{"pid": 1234, "name": "nginx", "cpu_percent": 0.5, ...}
```

**After (v0.1.14):**

```json
{
  "schema_id": "https://schemas.3leaps.dev/sysprims/process/v1.0.0/process-info.schema.json",
  "timestamp": "2026-...",
  "processes": [{"pid": 1234, "name": "nginx", "cpu_percent": 0.5, ...}]
}
```

**Root cause**: CLI `--pid` code path short-circuited to direct `ProcessInfo` serialization
instead of routing through the `SnapshotResult` envelope used by the list path.

**Fix scope**: `sysprims-cli` only. No library changes. No schema version bump.

Process-not-found: empty `processes: []` array, not a JSON parse error.

---

### Wave 2: CPU Mode Parity

#### `--cpu-mode` and `--sample` on `descendants` and `kill-descendants`

**The problem** (found during dogfooding on this repository):

Four zombie VSCodium plugin processes were spinning at ~100% CPU. Lifetime CPU mode
(the default, and the only mode available on `descendants`) found 2 of 4. Monitor
mode with 3-second sampling found all 4. The `kill-descendants` workflow — the
exact use case shown in the README — could not reliably target the offending processes.

```
# v0.1.13 — misses 2 of 4 spinning zombie processes
descendants 14796 --cpu-above 80
→ 2 matched (12967 showing 9.4%, 15956 showing 0.3% at snapshot time)

# v0.1.14 — finds all 4
descendants 14796 --cpu-mode monitor --sample 3s --cpu-above 80
→ 4 matched (all showing 100–101% over the sample window)
```

**Library change**: `DescendantsConfig` gains `cpu_mode: CpuMode` and
`sample_duration: Option<Duration>`. The descendant traversal uses these when
computing `cpu_percent` for filter matching, identical to how `pstat` uses them.

**Rust library**:

```rust
use sysprims_proc::{descendants_with_config, CpuMode, DescendantsConfig, ProcessFilter};
use std::time::Duration;

let config = DescendantsConfig {
    root_pid: parent_pid,
    max_levels: None, // all
    filter: Some(ProcessFilter {
        cpu_above: Some(80.0),
        ..Default::default()
    }),
    cpu_mode: CpuMode::Monitor,
    sample_duration: Some(Duration::from_secs(3)),
};
let result = descendants_with_config(config)?;
```

**Go binding**:

```go
// The complete surgical cleanup workflow using monitor sampling
cpuAbove := 80.0

// Preview with descendants filtering first
result, err := sysprims.DescendantsWithOptions(pid, &sysprims.DescendantsOptions{
    CpuMode:        sysprims.CpuModeMonitor,
    SampleDuration: 3 * time.Second,
    Filter:         &sysprims.ProcessFilter{CPUAbove: &cpuAbove},
})

// Then execute targeted descendant kill
killResult, err := sysprims.KillDescendantsWithOptions(pid, &sysprims.KillDescendantsOptions{
    CpuMode:        sysprims.CpuModeMonitor,
    SampleDuration: 3 * time.Second,
    Filter:         &sysprims.ProcessFilter{CPUAbove: &cpuAbove},
    Signal:         sysprims.SIGKILL,
})
_ = result
_ = killResult
```

**CLI** (wiring only — lib does the work):

```bash
sysprims descendants 14796 --cpu-mode monitor --sample 3s --cpu-above 80 --tree
sysprims kill-descendants 14796 --cpu-mode monitor --sample 3s --cpu-above 80 --dry-run
sysprims kill-descendants 14796 --cpu-mode monitor --sample 3s --cpu-above 80 --signal KILL --yes
```

**FFI**: `config_json` for `sysprims_proc_descendants` and `sysprims_proc_kill_descendants`
gains `cpu_mode` and `sample_duration_ms` fields.

**Schema**: lifetime descendants output remains `descendants-result.schema.json` v1.0.0;
monitor mode uses `descendants-result-sampled.schema.json` v1.1.0.

---

#### Contextual hint: `--cpu-above` without `--cpu-mode monitor`

When `--cpu-above` is specified and `--cpu-mode` is the default (`lifetime`) on `pstat`,
`descendants`, or `kill-descendants`, emit one line to stderr:

```
hint: --cpu-above uses lifetime CPU averaging; spinning/bursty processes may not appear.
      try: --cpu-mode monitor --sample 3s
```

Suppressed when: `--json` is active, `SYSPRIMS_NO_HINTS=1`, or `--cpu-mode` was explicitly set.

**Scope**: `sysprims-cli` only. No library changes.

---

### Wave 3: Documentation Sprint

#### CLI — Contextual help examples

`after_help` example blocks added to `pstat`, `descendants`, and `kill-descendants`.
Each block shows 3–4 real workflow examples, including the monitor-mode pattern.

`sysprims help <topic>` subcommand for concept-level reference:

- `sysprims help cpu-mode` — lifetime vs monitor, when to use each
- `sysprims help signals` — available signals, platform behavior
- `sysprims help safety` — PID safety rules summary

`SYSPRIMS_NO_HINTS=1` env var suppresses all hints and contextual messages (for scripts
and CI — output should be deterministic).

**Scope**: `sysprims-cli` only.

#### Library — rustdoc examples and Go pkg docs

Every public function in `sysprims-proc`, `sysprims-signal`, and `sysprims-timeout` gets
a `# Examples` block in rustdoc. Doc tests run in CI.

The narrative in each example follows: "replacing this shell-out" → sysprims equivalent.
Audience is engineers who are currently shelling out and considering the switch.

Go pkg docs (`pkg.go.dev`) updated to reflect v0.1.14 API surface including `proc_ext`
option pattern. The Go binding README gains a "replacing shell-outs" section.

**> prodmktg callout**: See [§ Documentation & Marketing Tasks](#documentation--marketing-tasks) below.

---

## Documentation & Marketing Tasks

_These are handed to prodmktg / developer relations at feature-complete, before release._

Delivered artifacts (Wave 3c):

- DM-1: `docs/guides/replace-shell-outs-go.md`
- DM-2: `docs/guides/process-intelligence-without-shell-outs.md`
- DM-3: `docs/one-pagers/go-team-adoption-v0.1.14.pdf` (source: `docs/one-pagers/go-team-adoption-v0.1.14.md`)
- DM-4: root `README.md` "As a Go Library" section updated for v0.1.14 API.

### DM-1 — "Replace your shell-outs" guide (Go focus)

A practical guide targeting Go platform engineers who currently shell out to `ps`, `lsof`,
and `kill`. Format: markdown in `docs/guides/`, linked from the Go binding README.

Show the before/after for each common pattern:

| Before (shell-out)                                  | After (sysprims Go)                                                          |
| --------------------------------------------------- | ---------------------------------------------------------------------------- |
| `exec.Command("ps", "eww", "-p", pid)` + text parse | `sysprims.ProcessGetWithOptions(pid, &ProcessOptions{IncludeEnv: true})`     |
| `exec.Command("ps", "-M", "-p", pid)` + count lines | `sysprims.ProcessGetWithOptions(pid, &ProcessOptions{IncludeThreads: true})` |
| `exec.Command("lsof", "-p", pid)` + text parse      | `sysprims.ListFds(pid, nil)`                                                 |
| `exec.Command("kill", "-9", pid)`                   | `sysprims.Kill(pid, sysprims.SIGKILL)`                                       |
| `exec.Command("kill", "-TERM", pgid)` + child leak  | `sysprims.KillDescendants(...)` with filter                                  |

Target length: 600–900 words. Include license cleanliness paragraph.

### DM-2 — "Process intelligence without shell-outs" blog post

One technical post, ~1000 words, targeting the Hacker News / lobste.rs audience.

Lead with the zombie process scenario (real-world: 4 VSCodium plugin processes at 100% CPU,
only 2 visible to lifetime snapshot, all 4 visible with 3-second monitor sampling).
Walk through the diagnosis workflow using sysprims CLI. Then show the same workflow
available programmatically via the Go library — no shell-outs, no text parsing,
no GPL in your supply chain.

Hook: the problem isn't just convenience. It's correctness. Lifetime CPU averaging is
structurally wrong for finding spinning processes. `pstat --cpu-mode monitor --sample 3s`
is not a workaround — it's the right measurement.

### DM-3 — Go team adoption one-pager

One page (A4/letter) PDF, designed for platform engineers to share internally when
proposing sysprims adoption. Content:

1. What sysprims is (two sentences)
2. License situation (MIT/Apache-2.0, no copyleft, embeds cleanly)
3. The three shell-outs it replaces for Go teams (`ps`, `lsof`, `kill` + tree)
4. v0.1.14 additions (env, threads, CPU mode on descendants)
5. Getting started snippet (5 lines of Go)
6. Where to file issues

### DM-4 — Update main README "As a Go Library" section

The current Go example in README covers `Kill()`, `RunWithTimeout()`, and `ListeningPorts()`.
Update to add `ProcessGetWithOptions()` with `ProcessOptions{IncludeEnv/IncludeThreads}`, and the
`KillDescendantsWithOptions()` with `CpuMode` workflow. The README is the first thing a Go engineer
sees on GitHub — it needs to show the full v0.1.14 surface.

---

## Platform Notes

### macOS

- `proc_ext` env: `KERN_PROCARGS2` buffer — same syscall as cmdline (v0.1.13). Second parse
  pass for env block. Requires no additional privileges for same-uid processes.
- `proc_ext` thread count: `proc_pidinfo(pid, PROC_PIDTASKINFO, ...)` → `proc_taskinfo.pti_threadnum`

### Linux

- `proc_ext` env: `/proc/[pid]/environ` (null-delimited). Readable without privilege for
  same-uid processes. Non-UTF-8 bytes handled with `from_utf8_lossy`.
- `proc_ext` thread count: `Threads:` field in `/proc/[pid]/status`.

### Windows

- `proc_ext` env: Not supported in v0.1.14 (returns `null`). Complex (requires `ReadProcessMemory`
  into PEB). Deferred.
- `proc_ext` thread count: `CreateToolhelp32Snapshot` + `Thread32First`/`Thread32Next`. Supported.

---

## Safety Considerations

### `proc_ext` (ADR-0011)

- `ProcessOptions` with `include_env: true` reads env from same-uid processes only.
  EPERM is handled gracefully — returns `env: null`, no error propagation.
- No new signal-sending code in this release.
- PID validation unchanged — all existing guards apply.

### CPU mode sampling

- Sampling is read-only. No signals sent during the sampling window.
- The CLI kill gate (`--yes`) remains unchanged.
- `--dry-run` in CLI always previews before acting regardless of cpu-mode.

---

## Schema Versions

| Schema                                   | v0.1.13 | v0.1.14 | Change                                                |
| ---------------------------------------- | ------- | ------- | ----------------------------------------------------- |
| `process-info.schema.json`               | v1.0.0  | v1.1.0  | Add `env`, `thread_count` (optional)                  |
| `process-info-sampled.schema.json`       | v1.0.0  | v1.1.0  | Keep sampled semantics aligned with `proc_ext` fields |
| `descendants-result.schema.json`         | v1.0.0  | v1.0.0  | No change (lifetime mode)                             |
| `descendants-result-sampled.schema.json` | —       | v1.1.0  | New sampled descendants contract (CPU may exceed 100) |
| `batch-kill-result.schema.json`          | v1.0.0  | v1.0.0  | No change                                             |

---

## Upgrade Notes

- **No breaking changes.** All changes are additive.
- `proc_ext` fields (`env`, `thread_count`) are `null`/`None` by default.
  Existing callers see no change in output unless they opt in via `ProcessOptions`.
- `pstat --pid --json` output changes shape (gains `schema_id` wrapper).
  Any consumer that was parsing the flat object directly will break.
  This is a fix for an ADR-0005 violation — the old output was non-conformant.
- `descendants` and `kill-descendants` CLI flags are additive — no existing invocations break.
- Go binding option types are additive — no existing call sites break.

---

## Delivery Sequence

| Wave | Scope                                                | Owner    | Gate                      |
| ---- | ---------------------------------------------------- | -------- | ------------------------- |
| 1a   | Schema fix (`pstat --pid --json`)                    | devlead  | secrev sign-off           |
| 1b   | `proc_ext` lib (env + threads), macOS + Linux        | devlead  | secrev sign-off           |
| 1c   | `proc_ext` FFI + Go + TS bindings                    | devlead  | binding conformance tests |
| 2a   | `DescendantsConfig` cpu_mode + sample_duration (lib) | devlead  | secrev sign-off           |
| 2b   | CPU mode wiring: CLI + FFI + Go + TS                 | devlead  | binding conformance tests |
| 2c   | Contextual hints (CLI-only)                          | devlead  | —                         |
| 3a   | CLI after_help examples + `sysprims help` subcommand | devlead  | —                         |
| 3b   | Rustdoc examples + Go pkg doc update                 | devlead  | doc tests in CI           |
| 3c   | DM-1 through DM-4                                    | prodmktg | deliverylead review       |

---

## References

- **Feature briefs**: `.plans/active/v0.1.14/feature-briefs.md`
- **ADR-0002**: Crate Structure (proc_ext feature flag origin)
- **ADR-0004**: FFI Design
- **ADR-0005**: Schema Contracts (schema_id requirement)
- **ADR-0011**: PID Validation Safety
- **Dogfooding session**: 2026-02-18, macOS arm64, 4 zombie VSCodium plugin processes
