# sysprims v0.1.6

**Release Date:** 2026-01-25
**Status:** Supervisor & Job Manager Primitives Release

## Summary

This release delivers process management primitives for long-running supervisors and job managers. Teams building systems like gonimbus or rampart lifecycle can now spawn kill-tree-safe jobs, detect PID reuse, and cleanly terminate process treesâ€”without coupling to the timeout API.

## Highlights

- **PID Reuse Guard**: New `start_time_unix_ms` and `exe_path` fields enable detection of PID reuse
- **Spawn In Group**: Create processes in a new process group (Unix) or Job Object (Windows)
- **Wait With Timeout**: Poll for process exit with configurable timeout
- **Terminate Tree**: Graceful-then-kill tree termination as a standalone primitive
- **Windows Documentation**: Job Object registry behavior documented

## New Primitives

| Primitive | Rust | FFI | Go | TypeScript |
|-----------|------|-----|-----|------------|
| Process identity | `ProcessInfo` | `sysprims_proc_get` | `ProcessGet` | `procGet` |
| Spawn in group | `spawn_in_group()` | `sysprims_spawn_in_group` | `SpawnInGroup` | `spawnInGroup` |
| Wait PID with timeout | `wait_pid()` | `sysprims_proc_wait_pid` | `WaitPID` | `waitPID` |
| Terminate tree | `terminate_tree()` | `sysprims_terminate_tree` | `TerminateTree` | `terminateTree` |

## Process Identity (PID Reuse Guard)

### Problem

Long-running supervisors store PIDs and later attempt to signal them. PID reuse can cause supervisors to accidentally target the wrong process after the original exits.

### Solution

The `ProcessInfo` struct now includes `start_time_unix_ms` and `exe_path` (when obtainable), allowing consumers to distinguish between "same PID, same process" and "same PID, different process" (PID reuse).

### Rust Usage

```rust
use sysprims_proc::get_process;

// At job creation, store identity
let info = get_process(pid)?;
let job_record = JobRecord {
    pid: info.pid,
    start_time: info.start_time_unix_ms,
    cmdline: info.cmdline.clone(),
};

// Later, before signaling
let current = get_process(job_record.pid)?;
if current.start_time_unix_ms != job_record.start_time {
    log::warn!("PID {} was reused, not signaling", job_record.pid);
    return Ok(JobStatus::Stale);
}
```

### Go Usage

```go
import "github.com/3leaps/sysprims/bindings/go/sysprims"

// At job creation
info, _ := sysprims.ProcessGet(pid)
jobRecord := JobRecord{
    PID:       info.PID,
    StartTime: info.StartTimeUnixMs,
}

// Later, before signaling
current, err := sysprims.ProcessGet(jobRecord.PID)
if err != nil || current.StartTimeUnixMs != jobRecord.StartTime {
    log.Printf("PID %d was reused or gone", jobRecord.PID)
    return
}
```

### TypeScript Usage

```typescript
import { procGet } from '@3leaps/sysprims';

// At job creation
const info = procGet(pid);
const jobRecord = {
  pid: info.pid,
  startTime: info.start_time_unix_ms,
};

// Later, before signaling
const current = procGet(jobRecord.pid);
if (current.start_time_unix_ms !== jobRecord.startTime) {
  console.warn(`PID ${jobRecord.pid} was reused, not signaling`);
  return;
}
```

### Platform Notes

| Platform | Source | Reliability |
|----------|--------|-------------|
| Linux | `/proc/<pid>/stat` starttime + boot time | High |
| macOS | `proc_pidinfo` / libproc APIs | High |
| Windows | Process creation time via Win32 | High |

The field is optional and omitted when not obtainable due to permissions.

## Spawn In Group

### Problem

Supervisors want "kill-tree safe" jobs without using `run_with_timeout`. Today, reliable grouping is mainly exercised through the timeout API.

### Solution

`spawn_in_group` spawns a child process in a new process group (Unix) or Job Object (Windows), returning identifiers needed for later tree termination.

### Rust Usage

```rust
use sysprims_timeout::{spawn_in_group, SpawnInGroupConfig};

let outcome = spawn_in_group(SpawnInGroupConfig {
    argv: vec!["./worker.sh".into(), "--id".into(), "42".into()],
    cwd: Some("/app".into()),
    env: Some(vec![("LOG_LEVEL".into(), "debug".into())]),
})?;

println!("Spawned PID {}", outcome.pid);
#[cfg(unix)]
println!("Process group: {}", outcome.pgid.unwrap());
println!("Tree kill reliability: {:?}", outcome.tree_kill_reliability);
```

### Go Usage

```go
import "github.com/3leaps/sysprims/bindings/go/sysprims"

config := sysprims.SpawnInGroupConfig{
    Argv: []string{"./worker.sh", "--id", "42"},
    Cwd:  "/app",
    Env:  map[string]string{"LOG_LEVEL": "debug"},
}

outcome, err := sysprims.SpawnInGroup(config)
if err != nil {
    log.Fatal(err)
}

log.Printf("Spawned PID %d", outcome.PID)
// outcome.PGID is nil on Windows
```

### TypeScript Usage

```typescript
import { spawnInGroup } from '@3leaps/sysprims';

const outcome = spawnInGroup({
  argv: ['./worker.sh', '--id', '42'],
  cwd: '/app',
  env: { LOG_LEVEL: 'debug' },
});

console.log(`Spawned PID ${outcome.pid}`);
// outcome.pgid is null on Windows
```

### SpawnInGroupResult Fields

| Field | Type | Description |
|-------|------|-------------|
| `schema_id` | string | Schema identifier |
| `timestamp` | string | RFC3339 timestamp |
| `platform` | string | Platform identifier |
| `pid` | u32 | Child process ID |
| `pgid` | u32? | Process group ID (Unix only; null on Windows) |
| `tree_kill_reliability` | string | `"guaranteed"` or `"best_effort"` |
| `warnings` | string[] | Platform-specific warnings |

### Platform Notes

- **Unix**: Uses `setpgid(0, 0)` to create new process group
- **Windows**: Creates Job Object with `JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE`
- **Degradation**: If Job Object creation fails (nested jobs, privilege limits), returns `tree_kill_reliability: best_effort`

## Wait PID With Timeout

### Problem

Graceful stop flows need to wait for process exit without blocking forever:
1. Send TERM
2. Wait up to N seconds
3. Send KILL if still running

### Solution

`wait_pid` polls for process exit with configurable timeout.

### Rust Usage

```rust
use sysprims_proc::wait_pid;
use std::time::Duration;

// Wait up to 10 seconds for exit
let outcome = wait_pid(pid, Duration::from_secs(10))?;

if outcome.timed_out {
    println!("Process {} did not exit, escalating to SIGKILL", pid);
} else if let Some(code) = outcome.exit_code {
    println!("Process {} exited with code {}", pid, code);
}
```

### Go Usage

```go
import (
    "time"
    "github.com/3leaps/sysprims/bindings/go/sysprims"
)

outcome, err := sysprims.WaitPID(pid, 10*time.Second)
if err != nil {
    log.Fatal(err)
}

if outcome.TimedOut {
    log.Printf("Process %d did not exit, escalating", pid)
} else {
    log.Printf("Process %d exited with code %d", pid, outcome.ExitCode)
}
```

### TypeScript Usage

```typescript
import { waitPID } from '@3leaps/sysprims';

const outcome = waitPID(pid, 10000); // 10 seconds in ms

if (outcome.timed_out) {
  console.log(`Process ${pid} did not exit, escalating`);
} else {
  console.log(`Process ${pid} exited with code ${outcome.exit_code}`);
}
```

### WaitPidResult Fields

| Field | Type | Description |
|-------|------|-------------|
| `schema_id` | string | Schema identifier |
| `timestamp` | string | RFC3339 timestamp |
| `platform` | string | Platform identifier |
| `pid` | u32 | PID waited on |
| `exited` | bool | True if process exited |
| `timed_out` | bool | True if timeout elapsed before exit |
| `exit_code` | i32? | Exit code (if exited and obtainable) |
| `warnings` | string[] | Platform-specific warnings |

### Platform Notes

- **Unix**: Polling via `kill(pid, 0)` (works for arbitrary PIDs; not parent-specific)
- **Windows**: `OpenProcess` + `WaitForSingleObject` (best-effort)

## Terminate Tree

### Problem

Consumers want a single "stop job" primitive that:
1. Attempts graceful termination
2. Waits for exit
3. Escalates to kill
4. Reports what happened

Today this is coupled to `run_with_timeout`'s spawned command management.

### Solution

`terminate_tree` provides one-call process tree termination, usable for arbitrary PIDs.

### Rust Usage

```rust
use sysprims_timeout::{terminate_tree, TerminateTreeConfig};

let outcome = terminate_tree(pid, TerminateTreeConfig {
    grace_timeout_ms: 5000,
    kill_timeout_ms: 2000,
    ..Default::default()
})?;

println!("Grace sent: {}", outcome.grace_sent);
println!("Escalated to kill: {}", outcome.escalated);
println!("Tree kill reliability: {:?}", outcome.tree_kill_reliability);

for warning in &outcome.warnings {
    eprintln!("Warning: {}", warning);
}
```

### Go Usage

```go
import "github.com/3leaps/sysprims/bindings/go/sysprims"

config := sysprims.TerminateTreeConfig{
    GraceTimeoutMs: 5000,
    KillTimeoutMs:  2000,
}

outcome, err := sysprims.TerminateTree(pid, config)
if err != nil {
    log.Fatal(err)
}

if outcome.Escalated {
    log.Printf("Had to escalate to SIGKILL")
}
```

### TypeScript Usage

```typescript
import { terminateTree } from '@3leaps/sysprims';

const outcome = terminateTree(pid, {
  grace_timeout_ms: 5000,
});

if (outcome.escalated) {
  console.log('Had to escalate to kill');
}

for (const warning of outcome.warnings) {
  console.warn(warning);
}
```

### TerminateTreeConfig Fields

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `signal` | signal | SIGTERM | Initial termination signal |
| `grace_timeout_ms` | u64 | 10000 | Wait time before escalation (milliseconds) |
| `kill_signal` | signal | SIGKILL | Escalation signal |
| `kill_timeout_ms` | u64 | 2000 | Wait time after kill signal (milliseconds) |

### TerminateTreeResult Fields

| Field | Type | Description |
|-------|------|-------------|
| `schema_id` | string | Schema identifier |
| `timestamp` | string | RFC3339 timestamp |
| `platform` | string | Platform identifier |
| `pid` | u32 | PID that was terminated |
| `pgid` | u32? | Process group ID (Unix only) |
| `signal_sent` | i32 | Signal sent for graceful termination |
| `kill_signal` | i32? | Kill signal (if escalated) |
| `escalated` | bool | Had to escalate to kill signal |
| `exited` | bool | Process tree exited |
| `timed_out` | bool | Overall operation timed out |
| `tree_kill_reliability` | string | `"guaranteed"` or `"best_effort"` |
| `warnings` | string[] | Platform-specific warnings |

## Adoption Guide

See [Supervisor Integration Guide](../guides/supervisor-integration.md) for recommended integration patterns.

### Recommended Integration Order

1. **Add PID identity checks**: Use `start_time_unix_ms` to detect PID reuse before signaling
2. **Replace stop flows with TerminateTree**: Single primitive for graceful-then-kill
3. **Upgrade spawn path with SpawnInGroup**: Ensure all jobs are kill-tree-safe by construction

## Changes

### Added

- **Process Identity Fields** (`sysprims-proc`)
  - `start_time_unix_ms` and `exe_path` fields in `ProcessInfo`
  - Best-effort on all platforms

- **Spawn In Group** (`sysprims-timeout`)
  - `spawn_in_group(config: SpawnInGroupConfig) -> SpawnInGroupResult`
  - FFI: `sysprims_spawn_in_group(config_json, *result_json_out)`
  - Bindings: Go `SpawnInGroup`, TypeScript `spawnInGroup`

- **Wait PID With Timeout** (`sysprims-proc`)
  - `wait_pid(pid, timeout) -> WaitPidResult`
  - FFI: `sysprims_proc_wait_pid(pid, timeout_ms, *json_out)`
  - Bindings: Go `WaitPID`, TypeScript `waitPID`

- **Terminate Tree** (`sysprims-timeout`)
  - `terminate_tree(pid, config) -> TerminateTreeResult`
  - FFI: `sysprims_terminate_tree`
  - Bindings: Go `TerminateTree`, TypeScript `terminateTree`

- **Documentation**
  - Job Object registry documentation for Windows

### Changed

- `ProcessInfo` schema updated with optional `start_time_unix_ms` and `exe_path`
- Go and TypeScript bindings updated for new primitives

## Platforms

| Platform | CLI | Go Bindings | TypeScript Bindings |
|----------|-----|-------------|---------------------|
| Linux x64 (glibc) | yes | yes | yes |
| Linux x64 (musl) | yes | yes | no |
| Linux arm64 (glibc) | yes | yes | yes |
| Linux arm64 (musl) | yes | yes | no |
| macOS x64 | yes | yes | yes |
| macOS arm64 | yes | yes | yes |
| Windows x64 | yes | yes | yes |

## Verification

Verify this release with the signed checksums:

```bash
# Download release and verification files
curl -LO https://github.com/3leaps/sysprims/releases/download/v0.1.6/SHA256SUMS
curl -LO https://github.com/3leaps/sysprims/releases/download/v0.1.6/SHA256SUMS.minisig
curl -LO https://github.com/3leaps/sysprims/releases/download/v0.1.6/sysprims-minisign.pub

# Verify signature
minisign -Vm SHA256SUMS -p sysprims-minisign.pub

# Verify checksums
shasum -a 256 -c SHA256SUMS --ignore-missing
```

## Next Release

v0.1.7+ will continue toward:
- Python bindings (cffi + wheel packaging)
- Timeout API for TypeScript (complex config struct)
- Extended self-introspection surface (`self_info` API)
