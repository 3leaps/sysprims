# v0.1.9 - 2026-02-01

**Status:** Process Visibility & Batch Operations Release

This release adds process visibility (`sysprims fds`) and batch signal operations (`sysprims kill` with multiple PIDs), completing the diagnostic and remediation toolkit for runaway process management.

## Highlights

- **`sysprims fds`**: Inspect open file descriptors (the `lsof` use-case, GPL-free)
- **Multi-PID Kill**: Batch signal delivery with per-PID result tracking
- **Complete Workflow**: From diagnosis (`pstat` → `fds`) to remediation (`kill` → `terminate-tree`)
- **Go Shared Library Mode**: Alpine/musl support via `-tags=sysprims_shared` for consumers linking multiple Rust staticlibs

## New CLI Commands

### `sysprims fds`

Inspect open file descriptors for any process:

```bash
# Table output for human inspection
sysprims fds --pid 88680 --table

# JSON output for scripting
sysprims fds --pid 88680 --json

# Filter by resource type
sysprims fds --pid 88680 --kind file --table
sysprims fds --pid 88680 --kind socket --json
```

Output (JSON):

```json
{
  "schema_id": "https://schemas.3leaps.dev/sysprims/process/v1.0.0/fd-snapshot.schema.json",
  "timestamp": "2026-02-01T17:40:10.702011Z",
  "platform": "macos",
  "pid": 88680,
  "fds": [
    {
      "fd": 5,
      "kind": "file",
      "path": "/Users/.../extension/state.json"
    },
    {
      "fd": 6,
      "kind": "socket"
    }
  ],
  "warnings": []
}
```

Options:

| Option          | Description                                    |
| --------------- | ---------------------------------------------- |
| `--pid <PID>`   | Process to inspect (required)                  |
| `--kind <TYPE>` | Filter by: `file`, `socket`, `pipe`, `unknown` |
| `--json`        | Output as JSON (default)                       |
| `--table`       | Human-readable table format                    |

**Platform Support:**

- **Linux**: Full file path resolution via `/proc/<pid>/fd/`
- **macOS**: Best-effort path recovery via `proc_pidinfo()`
- **Windows**: Returns error (not supported; requires elevated privileges)

### Multi-PID Kill

Send signals to multiple processes in one call:

```bash
# Kill multiple specific PIDs
sysprims kill 88680 88681 88682 -s TERM

# With JSON output showing per-PID results
sysprims kill 88680 88681 88682 -s TERM --json
```

Output (JSON):

```json
{
  "schema_id": "https://schemas.3leaps.dev/sysprims/signal/v1.0.0/batch-kill-result.schema.json",
  "signal_sent": 15,
  "succeeded": [88680, 88681],
  "failed": [{ "pid": 88682, "error": "Process not found" }]
}
```

Exit codes:

- `0`: All PIDs signaled successfully
- `1`: Some PIDs failed (partial success)
- `2`: All PIDs failed or validation error

**Key behavior:** All PIDs are validated before any signals are sent. Individual failures don't abort the batch.

## Complete Runaway Process Workflow

```bash
# 1. Find high-CPU processes
sysprims pstat --cpu-mode monitor --cpu-above 50 --sort cpu --table

# 2. Inspect what files they have open
sysprims fds --pid <PID> --kind file --json

# 3. Kill runaway processes (surgical)
sysprims kill <PID> <PID> ... -s TERM

# 4. If that doesn't work, terminate the tree
sysprims terminate-tree <PARENT_PID> --require-exe-path <PATH>
```

See the updated [runaway process diagnosis guide](../docs/guides/runaway-process-diagnosis.md) for the full walkthrough.

## Documentation

- **New App Note**: `docs/appnotes/fds-validation/`
  - Synthetic test cases for validating `sysprims fds` output
  - Demonstrates platform differences (Linux full paths vs macOS best-effort)
- **Updated Guide**: `docs/guides/runaway-process-diagnosis.md`
  - Now includes `sysprims fds` for root cause identification
  - Documents the complete diagnostic workflow

## Library API (Rust)

```rust
use sysprims_proc::{list_fds, FdFilter, FdKind};
use sysprims_signal::kill_many;

// Inspect file descriptors
let filter = FdFilter { kind: Some(FdKind::File) };
let snapshot = list_fds(pid, Some(&filter))?;

// Batch signal delivery
let result = kill_many(&[pid1, pid2, pid3], SIGTERM)?;
```

## Language Bindings

Both features are available in Go and TypeScript:

**Go:**

```go
// List file descriptors
snapshot, err := sysprims.ListFds(pid, &sysprims.FdFilter{Kind: sysprims.FdKindFile})

// Batch kill
result, err := sysprims.KillMany([]uint32{pid1, pid2, pid3}, sysprims.SIGTERM)
```

**TypeScript:**

```typescript
// List file descriptors
const snapshot = listFds(pid, { kind: "file" });

// Batch kill
const result = killMany([pid1, pid2, pid3], SIGTERM);
```

## Go Shared Library Mode

Go bindings now support two linkage modes: default static and opt-in shared (sysprims_shared). Shared mode exists to avoid link-time failures when a Go consumer also links another Rust staticlib via cgo (duplicate Rust runtime symbols like \_rust_eh_personality). It also improves "it just runs" developer experience by embedding rpath/runpath entries so users don't need DYLD_LIBRARY_PATH/LD_LIBRARY_PATH.

### What changed (user-facing)

- New build tag: sysprims_shared
  - Default remains static (no tags required)
  - Shared mode links against prebuilt dynamic libraries shipped with the Go module
- Shared libraries are now produced and packaged for:
  - macOS: libsysprims_ffi.dylib (install name set to @rpath/libsysprims_ffi.dylib)
  - Linux glibc: libsysprims_ffi.so
  - Linux musl (Alpine): libsysprims_ffi.so
  - Windows (GNU toolchain): sysprims_ffi.dll + libsysprims_ffi.dll.a
- rpath embedding:
  - Shared mode cgo flags embed rpaths pointing at the module's vendored lib-shared/... directories (${SRCDIR}/lib-shared/...), so go test / local builds run without extra env vars.

### How to use (copy/paste)

- Default static mode (recommended unless you hit Rust staticlib collisions):
  - `go test ./...`
- Shared mode (avoids duplicate Rust runtime symbols; requires dynamic libs at runtime):
  - macOS / Linux glibc: `go test -tags=sysprims_shared ./...`
  - Alpine/musl: `go test -tags="musl,sysprims_shared" ./...`

### Directory layout in the Go module

- Static libs: bindings/go/sysprims/lib/<platform>/libsysprims_ffi.a
- Shared libs: bindings/go/sysprims/lib-shared/<platform>/:
  - macOS: libsysprims_ffi.dylib
  - Linux: libsysprims_ffi.so
  - Windows: sysprims_ffi.dll + libsysprims_ffi.dll.a
- Optional local overrides (developer builds): bindings/go/sysprims/lib-shared/local/<platform>/

### Runtime / distribution guidance (important)

- The embedded ${SRCDIR} rpaths are primarily for local dev and go test; downstream distributors should bundle the shared library with their binary and use:
  - macOS: @executable_path rpath + ship libsysprims_ffi.dylib next to the executable
  - Linux: $ORIGIN rpath + ship libsysprims_ffi.so next to the executable
  - Windows: ship sysprims_ffi.dll next to the executable (or ensure it's on PATH)

### CI validation credibility

- We validate the Alpine/musl shared story end-to-end in CI by running Go tests inside an Alpine container with -tags="musl,sysprims_shared" and a vendored libsysprims_ffi.so in the expected lib-shared path.

### Suggested doc copy (one-liner)

- "If your Go app links another Rust staticlib via cgo and hits duplicate-symbol link errors, rebuild with -tags=sysprims_shared (or -tags="musl,sysprims_shared" on Alpine) to use sysprims as a shared library."

**Platform Support:**

| Platform      | Static | Shared | Build Tags             |
| ------------- | ------ | ------ | ---------------------- |
| macOS (arm64) | ✓      | ✓      | `sysprims_shared`      |
| Linux glibc   | ✓      | ✓      | `sysprims_shared`      |
| Linux musl    | ✓      | ✓      | `musl,sysprims_shared` |
| Windows       | ✓      | ✓      | `sysprims_shared`      |
| Windows ARM64 | ✓      | ✗      | N/A                    |

Shared libraries use rpath for runtime resolution and are validated in CI via Alpine containers for musl support.
